\section{Introduction}\label{introduction}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Relevance: importance of networking for Scala.js
\item
  Motivation: Many JS APIs

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Websocket
  \item
    Comet
  \item
    WebRTC
  \end{itemize}
\item
  Motivation: Many network programing models

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Akka
  \item
    RPC (type safe)
  \item
    Steams (scalaz, akka-stream)
  \end{itemize}
\item
  Plan/Contributions
\end{itemize}

\newpage

\section{Transport}\label{transport}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  This section, scala-js-transport library, main contribution
\end{itemize}

\subsection{A Uniform Interface}\label{a-uniform-interface}

We begin our discussion by the definition of an interface for
asynchronous transports. This interface aims at \emph{transparently}
modeling the different underlying technologies, meaning that is simply
delegates tasks to the actual implementation, without adding new
functionalities.

\transportInterface

A \emph{Transport} can both \emph{listen} for incoming connections and
\emph{connect} to remote \emph{Transports}. Platforms limited to act
either as client or server will return a failed future for either of
these methods. In order to listen for incoming connections, the user of
a \emph{Transport} has to complete the promise returned by the listen
method with a \emph{ConnectionListener}. To keep the definition generic,
\emph{Address} is an abstract type. As we will see later, it varies
greatly from one technology to another.

\emph{ConnectionHandle} represents an opened connection. Thereby, it
supports four type of interactions: writing a message, listening for
incoming messages, closing the connection and listening for connection
closure. Similarly to \emph{Transport}, listening for incoming messages
is achieved by completing a promise of \emph{MessageListener}.

The presented \emph{Transport} and \emph{ConnectionHandle} interfaces
have several advantages compared to their alternative in other
languages, such the WebSocket interface in JavaScript. For example,
errors are not transmitted by throwing exceptions, but simply returned
as a failed future. Also, some incorrect behaviors such as writing to a
no yet opened connection, or receiving duplicate notifications for a
closed connection, are made impossible by construction. Thanks to
support of futures and promises in Scala.js, these interfaces cross
compile to both Java bytecode and JavaScript.

\subsection{Implementations}\label{implementations}

The scala-js-transport library contains several implementations of
\emph{Transports} for WebSocket, SockJS and WebRTC. This subsection
briefly presents the different technologies and their respective
advantages. \autoref{impl-summary} summarizes the available
\emph{Transports} for each platform and technology.

\begin{longtable}[c]{@{}lccc@{}}
\caption{Summary of the available
\emph{Transports}.\label{impl-summary}}\tabularnewline
\toprule
Platform & WebSocket & SockJS & WebRTC\tabularnewline
\midrule
\endfirsthead
\toprule
Platform & WebSocket & SockJS & WebRTC\tabularnewline
\midrule
\endhead
JavaScript & client & client & client\tabularnewline
Play Framework & server & server & -\tabularnewline
Netty & both & - & -\tabularnewline
Tyrus & client & - & -\tabularnewline
\bottomrule
\end{longtable}

\subsubsection{WebSocket}\label{websocket}

WebSocket provides full-duplex communication over a single TCP
connection.

Connection establishment begin with an HTTP request from client to
server. After the handshake is completed, the TCP connection used for
the initial HTTP request is \emph{upgraded} to change protocol, and kept
open to become the actual WebSocket connection. This mechanism allows
WebSocket to be wildly supported over different network configurations.

WebSocket is also well supported across different platforms. Our library
provides four WebSocket \emph{Transports}, a native JavaScript client, a
Play Framework server, a Netty client/server and a Tyrus client. While
having all three Play, Netty and Tyrus might seem redundant, each of
them comes with its own advantages. Play is a complete web framework,
suitable to build every component of a web application. Play is based on
Netty, which means that for a standalone WebSocket server, using Netty
directly leads to better performances and less dependencies. Regarding
client side, the Tyrus library offers a standalone WebSocket client
which is lightweight compared to the Netty framework.

\subsubsection{SockJS}\label{sockjs}

SockJS is a WebSocket emulation protocol which fallbacks to different
protocols when WebSocket is not supported. Is supports a large number of
techniques to emulate the sending of messages from server to client,
such as AJAX long polling, AJAX streaming, EventSource and streaming
content by slowly loading an HTML file in an iframe. These techniques
are based on the following idea: by issuing a regular HTTP request from
client to server, and voluntarily delaying the response from the server,
the server side can decide when to release information. This allows to
emulate the sending of messages from server to client which not
supported in the traditional request-response communication model.

The scala-js-transport library provides a \emph{Transport} build on the
official SockJS JavaScript client, and a server on the Play Framework
via a community plugin \cite{play2-sockjs}. Netty developers have
scheduled SockJS support for the next major release.

\subsubsection{WebRTC}\label{webrtc}

WebRTC is an experimental API for peer to peer communication between web
browsers. Initially targeted at audio and video communication, WebRTC
also provides \emph{Data Channels} to communicate arbitrary data.
Contrary to WebSocket only supports TCP, WebRTC can be configures to use
either TCP, UDP or SCTP.

As opposed to WebSocket and SockJS which only need a URL to establish a
connection, WebRTC requires a \emph{signaling channel} in order to open
the peer to peer connection. The \emph{signaling channel} is not tight
to a particular technology, its only requirement is to allow a back an
forth communication between peers. This is commonly achieved by
connecting both peers via WebSocket to a server, which then serves as a
relay for the WebRTC connection establishment.

To simplify the process of relaying messages from one peer to another,
our library uses picklers for \emph{ConnectionHandle}. Concretely, when
a \emph{ConnectionHandle} object connecting node \emph{A} and \emph{B}
is sent by \emph{B} over an already established connection with
\emph{C}, the \emph{ConnectionHandle} received by \emph{C} will act as a
connection between \emph{A} and \emph{C}, hiding the fact that \emph{B}
relays messages between the two nodes.

At the time of writing, WebRTC is implemented is Chrome, Firefox and
Opera, and lakes support in Safari and Internet Explorer. The only non
browser implementations are available on the node.js platform.

\subsection{Wrappers}\label{wrappers}

Thanks to the \emph{Transport} interface, it is possible write programs
with an abstract communication medium. We present two wrappers, for Akka
\cite{akka} and Autowire~\cite{autowire}, which allow to work at
different level of abstraction compared to the direct use of a
\emph{Transport}. Because Autowire and Akka (via \cite{scala-js-actors})
can both be used on the JVM and on JavaScript, these wrappers can be
used to build cross compiling programs compatible with all the
\emph{Transport} implementations presented in \autoref{implementations}.

\subsubsection{Akka}\label{akka}

\subsubsection{Autowire RPC}\label{autowire-rpc}

\subsubsection{Going further}\label{going-further}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Testing infrastructure
\item
  Two configurable browsers
\end{itemize}

\newpage

\section{Example: A Cross-platform Multiplayer
Game}\label{example-a-cross-platform-multiplayer-game}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Goal: Cross platform JS/JVM realtime mutiplayer game
\item
  History: Scala.js port of a JS port of a Commodore 64 game
\end{itemize}

\subsection{Architecture}\label{architecture}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Purely functional multiplayer game engine
\item
  Clock synked, same game simulated on both platforms
\item
  Requires: initialState, nextState, render, transport
\item
  Result: Immutability everywhere
\item
  Result: everything but input handler \& UI is shared
\end{itemize}

\subsection{Compensate Network
Latency}\label{compensate-network-latency}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Traditional solutions (actual lag, fixed delay with animation)
\item
  Solution: go back in time (Figure)
\item
  Scala List and Ref quality and fixed size buffer solution
\end{itemize}

\subsection{Implementation}\label{implementation}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  React UI (\& hack for the JVM version)
\item
  Simple Server for matchmaking
\item
  WebRTC with SockJS fallback
\item
  Results: 60FPS on both platforms, lag free gameplay
\item
  Results: Lag Compensation in action (Screenshots)
\end{itemize}

\newpage

\section{Related Work}\label{related-work}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Js/NodeJs, relies on duck typing
\item
  Closure
\item
  Steam Engine/AoE/Sc2/Google docs
\end{itemize}

\newpage

\section{Conclusion and Future Work}\label{conclusion-and-future-work}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Web workers
\item
  scalaz-stream/akka-stream wrappers
\item
  More utilities on top of Transport
\end{itemize}
