\chapter{Introduction}\label{introduction}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Context: What is Scala.js
\item
  Relevance: importance of networking for Scala.js
\item
  Motivation: Many JS APIs

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Websocket
  \item
    Comet
  \item
    WebRTC
  \end{itemize}
\item
  Motivation: Many network programing models

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    Akka
  \item
    RPC (type safe)
  \item
    Steams (scalaz, akka-stream)
  \end{itemize}
\item
  Plan/Contributions
\end{itemize}

\chapter{Transport}\label{transport}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  This section, scala-js-transport library, main contribution
\end{itemize}

\section{A Uniform Interface}\label{a-uniform-interface}

We begin our discussion by the definition of an interface for
asynchronous transports, presented in \autoref{transportInterface}. This
interface aims at \emph{transparently} modeling the different underlying
technologies, meaning that is simply delegates tasks to the actual
implementation, without adding new functionalities.

\transportInterface{Definition of the core networking interfaces.}

A \emph{Transport} can both \emph{listen} for incoming connections and
\emph{connect} to remote \emph{Transports}. Platforms limited to act
either as client or server will return a failed future for either of
these methods. In order to listen for incoming connections, the user of
a \emph{Transport} has to complete the promise returned by the listen
method with a \emph{ConnectionListener}. To keep the definition generic,
\emph{Address} is an abstract type. As we will see later, it varies
greatly from one technology to another.

\emph{ConnectionHandle} represents an opened connection. Thereby, it
supports four type of interactions: writing a message, listening for
incoming messages, closing the connection and listening for connection
closure. Similarly to \emph{Transport}, listening for incoming messages
is achieved by completing a promise of \emph{MessageListener}.

The presented \emph{Transport} and \emph{ConnectionHandle} interfaces
have several advantages compared to their alternative in other
languages, such the WebSocket interface in JavaScript. For example,
errors are not transmitted by throwing exceptions, but simply returned
as a failed future. Also, some incorrect behaviors such as writing to a
no yet opened connection, or receiving duplicate notifications for a
closed connection, are made impossible by construction. Thanks to
support of futures and promises in Scala.js, these interfaces cross
compile to both Java bytecode and JavaScript.

\section{Implementations}\label{implementations}

The scala-js-transport library contains several implementations of
\emph{Transports} for WebSocket, SockJS and WebRTC. This subsection
briefly presents the different technologies and their respective
advantages. \autoref{impl-summary} summarizes the available
\emph{Transports} for each platform and technology.

\begin{longtable}[c]{@{}lccc@{}}
\caption{Summary of the available
Transports.\label{impl-summary}}\tabularnewline
\toprule
Platform & WebSocket & SockJS & WebRTC\tabularnewline
\midrule
\endfirsthead
\toprule
Platform & WebSocket & SockJS & WebRTC\tabularnewline
\midrule
\endhead
JavaScript & client & client & client\tabularnewline
Play Framework & server & server & -\tabularnewline
Netty & both & - & -\tabularnewline
Tyrus & client & - & -\tabularnewline
\bottomrule
\end{longtable}

\subsection{WebSocket}\label{websocket}

WebSocket provides full-duplex communication over a single TCP
connection. Connection establishment begin with an HTTP request from
client to server. After the handshake is completed, the TCP connection
used for the initial HTTP request is \emph{upgraded} to change protocol,
and kept open to become the actual WebSocket connection. This mechanism
allows WebSocket to be wildly supported over different network
configurations.

WebSocket is also well supported across different platforms. Our library
provides four WebSocket \emph{Transports}, a native JavaScript client, a
Play Framework server, a Netty client/server and a Tyrus client. While
having all three Play, Netty and Tyrus might seem redundant, each of
them comes with its own advantages. Play is a complete web framework,
suitable to build every component of a web application. Play is based on
Netty, which means that for a standalone WebSocket server, using Netty
directly leads to better performances and less dependencies. Regarding
client side, the Tyrus library offers a standalone WebSocket client
which is lightweight compared to the Netty framework.

\subsection{SockJS}\label{sockjs}

SockJS is a WebSocket emulation protocol which fallbacks to different
protocols when WebSocket is not supported. Is supports a large number of
techniques to emulate the sending of messages from server to client,
such as AJAX long polling, AJAX streaming, EventSource and streaming
content by slowly loading an HTML file in an iframe. These techniques
are based on the following idea: by issuing a regular HTTP request from
client to server, and voluntarily delaying the response from the server,
the server side can decide when to release information. This allows to
emulate the sending of messages from server to client which not
supported in the traditional request-response communication model.

The scala-js-transport library provides a \emph{Transport} build on the
official SockJS JavaScript client, and a server on the Play Framework
via a community plugin \cite{play2-sockjs}. Netty developers have
scheduled SockJS support for the next major release.

\subsection{WebRTC}\label{webrtc}

WebRTC is an experimental API for peer to peer communication between web
browsers. Initially targeted at audio and video communication, WebRTC
also provides \emph{Data Channels} to communicate arbitrary data.
Contrary to WebSocket only supports TCP, WebRTC can be configures to use
either TCP, UDP or SCTP.

As opposed to WebSocket and SockJS which only need a URL to establish a
connection, WebRTC requires a \emph{signaling channel} in order to open
the peer to peer connection. The \emph{signaling channel} is not tight
to a particular technology, its only requirement is to allow a back an
forth communication between peers. This is commonly achieved by
connecting both peers via WebSocket to a server, which then serves as a
relay for the WebRTC connection establishment.

To simplify the process of relaying messages from one peer to another,
our library uses picklers for \emph{ConnectionHandle}. Concretely, when
a \emph{ConnectionHandle} object connecting node \emph{A} and \emph{B}
is sent by \emph{B} over an already established connection with
\emph{C}, the \emph{ConnectionHandle} received by \emph{C} will act as a
connection between \emph{A} and \emph{C}, hiding the fact that \emph{B}
relays messages between the two nodes.

At the time of writing, WebRTC is implemented is Chrome, Firefox and
Opera, and lakes support in Safari and Internet Explorer. The only non
browser implementations are available on the node.js platform.

\section{Wrappers}\label{wrappers}

By using \emph{Transport} interface, it is possible write programs with
an abstract communication medium. We present two \emph{Transport}
wrappers, for Akka \cite{akka} and Autowire~\cite{autowire}, which allow
to work with different model of concurrency. Because Autowire and Akka
(via \cite{scala-js-actors}) can both be used on the JVM and on
JavaScript, these wrappers can be used to build cross compiling programs
compatible with all the \emph{Transport} implementations presented in
\autoref{implementations}.

\subsection{Akka}\label{akka}

The actor model is based on asynchronous message passing between
primitive entities called actors. Featuring both location transparency
and fault tolerance via supervision, the actor model is particularly
adapted to distributed environment. Akka, a toolkit build around the
actor model for the JVM, was partly ported to Scala.js by S. Doeraene in
\cite{scala-js-actors}. The communication interface implemented in
\cite{scala-js-actors} was revisited into the \emph{Transport} wrapper
presented in \autoref{actorWrapper}.

\actorWrapper{Transport wrappers to handle connections with actors.}

The two methods \emph{acceptWithActor} and \emph{connectWithActor} use
the underlying \emph{listen} and \emph{connect} methods of the wrapped
\emph{Transport}, and create an \emph{handler} actor to handle the
connection. The semantic is as follows: the \emph{handler} actor is
given an \emph{ActorRef} in it is constructor, to which sending messages
results in sending outgoing messages thought the connection, and
messages received by the \emph{handler} actor are incoming messages
received from the connection. Furthermore, the life span of an
\emph{handler} actor is tight to life span of its connection, meaning
that the \emph{preStart} and \emph{postStop} hooks can be used to detect
the creation and the termination of the connection, and killing the
\emph{handler} actor results in closing the connection.
\autoref{yellingActor} shows an example of a simple \emph{handler} actor
which than sending back whatever it receives in uppercase.

\yellingActor{Example of a connection handling actor.}

Thanks to the picking mechanism developed in \cite{scala-js-actors}, it
is possible to sent messages of any type thought a connection, given
that implicit picklers are available for these types of messages. Out of
the box, picklers for case classes and case objects can be
macros-generated by the pickling library. In addition, an
\emph{ActorRef} pickler allows the transmission of \emph{ActorRefs}
thought a connection, making them transparently usable from the side of
the connection as if they were references to local actors.

\subsection{Autowire}\label{autowire}

Remote procedure call allow remote systems to communicate through an
interface similar to method calls. The Autowire library allows to
perform type-safe, reflection-free remote procedure calls between Scala
system. It uses macros and is agnostic of both the transport-mechanism
and the serialization library.

The scala-js-transport library offers a \emph{RpcWrapper}, which makes
internal use of Autowire to provide remote provide call on top of any of
the available \emph{Transports}. Because the \emph{Transport} interface
communicates with \emph{Strings}, the \emph{RpcWrapper} is able to set
all the type parameters of Autowire, as well embedding the uPickle
serialization library \cite{upickle}, thus trading flexibility to reduce
boilerplate. \autoref{rpcExample} shows a complete remote procedure call
implementation on top of WebSocket.

\rpcExample{Example of remote procedure call implementation.}

The main strength of remote procedure calls are their simplicity and
type-safety. Indeed, because of how similar remote procedure calls are
to actual method calls, they can be used without any learning curve, and
consistency between client and server side is can be verified by the
compiler. However, this simplicity also comes with some draw backs.
Contrary to the actor model which can be used to explicitly model the
life span of connections, and different types of failures, there are no
such things build in when using remote procedure calls. In order to
implement a fine grain error detection and recovery mechanism on top of
recovery procedure calls, one would have to work at a lower lever than
the one offered by the model it self, which is with the \emph{Transport}
interface in our case.

\section{Going further}\label{going-further}

The different \emph{Transport} implementations and wrappers presented is
this section allows for several interesting combinations. Because the
scala-js-transport library is built with a central communication
interface (presented in \autoref{a-uniform-interface}), it is easily
expendable in both directions. Indeed, any new implementation of the
\emph{Transport} interface with a different underlaying technologies
would immediately be usable with the different wrappers. Analogously,
any new wrapper on top of the \emph{Transport} interface would
automatically be compatible with the variety of available
implementations.

All the implementations and wrappers are accompanied by integration
tests. In most cases, these tests are built using the \emph{Selenium
WebDriver} included in the Play Framework test tools, which allow to
access proper behavior of the library using real web browsers. Our tests
for WebRTC include an extension of the default Play test tools to use
two browsers on a single test. The tests can then be configures to run
with two different browsers, such as Chrome and Firefox, to test their
compatibility.

\chapter{Dealing with latency}\label{dealing-with-latency}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  This section, the framework, the game
\end{itemize}

\section{Latency Compensation}\label{latency-compensation}

Working with distributed systems introduces numerous challenges compared
to the use of a single machine. Much of the complexity comes from the
communication links; limited throughput, risk of failure, and latency
all have to taken into consideration. Our discussion will be focused on
issues related to latency.

When thinking about latency sensitive application, the things that comes
to mind might be multiplayer video games. In order to provide a fun and
immersive experience, real-time games have to \emph{feel} reactive.
Techniques to compensate network latency also have uses in online
communication/collaboration tools. Essentially, any application where a
shared state can be simultaneously mutated by different peers is
confronted with this problem. According to \cite{timelines2013}, the
different latency compensation mechanisms can be divided into three
categories: predictive techniques, delayed input techniques and
time-offsettings techniques.

\emph{Predictive techniques} estimate the current value of the global
state using information available locally. These techniques are
traditionally implemented using a central authoritative server which
gathers inputs from all clients, computes the value of global state, and
broadcasts this state back to all clients. It then possible to do
prediction on the client side by computing a "throwaway" state using the
latest local inputs, which is later replaced by the state the server as
soon as it is received. This architecture with a central authoritative
server is used in most \emph{First person shooter} games, such as the
ones built using the Source Engine \cite{source-engine}.

\emph{Delayed input techniques} defer the execution of all actions to
allow simultaneous execution by all client. Very often, the perceived
latency can be reduced by instantly starting a purely visual animation
as soon as the an input is entered but still delaying the any actual
effect of the action. This solution is typically used in games where the
game state is too large to be frequently sent over the network. In this
case, peers would directly exchange the user inputs and simultaneously
simulate the game with a fixed delay. Having a centralized server is
then not mandatory, and peer to peer configurations might be used to
reduce communication latency. The classical \emph{Age of Empires} uses
the input delayed techniques with a fixed delay of 500 ms \cite{aoe}.

\TODO{*Time-offsettings techniques*}...
\cite{local-perception-filter1998}.

Each technique comes with its own advantages and disadvantages, and are
essentially making different tradeoffs between consistency and
responsiveness. Without going into further details on the different
latency compensation techniques, this introduction should give the
reader an idea of the variety of possible solutions and their respective
sophistication.

\section{A Functional Framework}\label{a-functional-framework}

We now present a Scala framework for latency compensation. By imposing a
purely functional design to its users, the framework is focused on
correctness, leaving very little room for runtime errors.

It implements predictive latency compensation in a distributed fashion.
As opposed to traditional architecture for prediction such as the one
described in \cite{source-engine}, our framework does uses any
authoritative node to hold the global state of the application, but
functions in a purely peer to peer fashion.

To do so, each peer runs a local simulation of the application up to the
current time, using all the inputs available. Whenever an input is
transmitted at a peer via the network, this remote input is necessarily
slightly out of date because of the communication latency. In order to
incorporate out of date input into the local simulation, the framework
rolls back the state of the simulation as it was just before the time of
emission of this input, and replays the simulation until the current
time, thus taking into account the remote input. \autoref{stateGraph}
shows this process in action from the point of view of peer \emph{P1}.
In this example, \emph{P1} emits an input at time \emph{t2}, and then,
at time \emph{t3}, receives an input from \emph{P2} which was emitted at
time \emph{t1}. The framework then invalidates a branch of the state
tree, \emph{S2-S3}, and computes \emph{S2'-S3'-S4'} which take into
account both inputs.

\stateGraph{The figure...}

eventually consistent instant feed back

\begin{itemize}
\item
  The solution: simulate with local inputs, go back in time when getting
  remote inputs (Figure)
\item
  Functional interface (Listing)
\item
  Requires: initialState, nextState, render, transport
\end{itemize}

\section{Architecture and
Implementation}\label{architecture-and-implementation}

\begin{itemize}
\item
  \cite{aoe} issues about determinism and game states getting
  out-of-sync
\item
  Identical simulation on all peers
\item
  Immutability everywhere
\item
  Pure function
\item
  Goal: Cross platform JS/JVM realtime lag compensation framework
\end{itemize}

\subsection{clock sync}\label{clock-sync}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Where do we cheat: clock sync
\end{itemize}

\subsection{back in time}\label{back-in-time}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Scala List and Ref quality and fixed size buffer solution
\end{itemize}

\section{Putting It All Together: A Real-Time Multiplayer
Game}\label{putting-it-all-together-a-real-time-multiplayer-game}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  History: Scala.js port of a JS port of a Commodore 64 game
\item
  Functional GUI with React (Hack for the JVM version)
\item
  Everything but input handler shared (but UI shouldn't...)
\item
  Functional design of gun fire (-\textgreater{} function of time!)
\item
  WebRTC with SockJS fallback
\item
  Live reload heaven
\item
  Results: 60FPS on both platforms, lag free gameplay
\item
  Results: Lag Compensation in action (Screenshots)
\end{itemize}

\chapter{Related Work}\label{related-work}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Js/NodeJs, relies on duck typing
\item
  Closure
\item
  Steam Engine/AoE/Sc2
\item
  \cite{timelines2013}
\item
  Cheating concerns
\end{itemize}

\chapter{Conclusion and Future Work}\label{conclusion-and-future-work}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Web workers
\item
  scalaz-stream/akka-stream wrappers
\item
  More utilities on top of Transport
\end{itemize}

\appendix\clearpage\addappheadtotoc

\chapter{React}\label{react}

\TODO{React} \cite{react} is a JavaScript library for building user
interfaces.

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Just the UI: Lots of people use React as the V in MVC. Since React
  makes no assumptions about the rest of your technology stack, it's
  easy to try it out on a small feature in an existing project.
\item
  Virtual DOM: React uses a virtual DOM diff implementation for
  ultra-high performance. It can also render on the server using
  Node.js, no heavy browser DOM required.
\item
  Data flow: React implements one-way reactive data flow which reduces
  boilerplate and is easier to reason about than traditional data
  binding.
\end{itemize}
